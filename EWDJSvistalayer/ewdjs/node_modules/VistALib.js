/*

VistALib: Generic EWD.js Utility Functions for VistA REST Access

*/

// Crypto functions

var crypto = require('crypto');
//var chemHemLib = require('vistaChemHemLib');

var encryptCredentials = function(accessCode, verifyCode, key) {
  var text = 'accessCode:' + accessCode + ';verifyCode:' + verifyCode;
  return text;
  /*  REAL CODE
  var cipher = crypto.createCipher('aes-256-cbc',key);
  //var iv = new Buffer(crypto.randomBytes(16));
  //var iv = new Buffer('raptorraptor2015','utf-8');	//16 chars todo randomize
  //var cipher = crypto.createCipheriv('aes-256-cbc',key,iv);
  var crypted = cipher.update(text,'utf8','hex');
  crypted += cipher.final('hex');
  return crypted;
  */
};

var decryptCredentials = function(encryptedString, key) {

  var dec;
  try {
    dec = encryptedString; //decipher.update(encryptedString,'hex','utf8')
    var str = dec.split('accessCode:')[1];
    var pieces = str.split(';verifyCode:');
    return {
      accessCode: pieces[0],
      verifyCode: pieces[1]
    };
  }
  catch(err) {
    return errorResponse('Invalid FAKE credentials', 400);
  }
	
  /*	REAL CODE
  var decipher = crypto.createDecipher('aes-256-cbc', key);
  //var iv = new Buffer('raptorraptor2015','utf-8');	//16 chars todo randomize
  //var decipher = crypto.createDecipheriv('aes-256-cbc',key,iv);
  var dec;
  try {
    dec = decipher.update(encryptedString,'hex','utf8')
    dec += decipher.final('utf8');
    var str = dec.split('accessCode=')[1];
    var pieces = str.split('&verifyCode=');
    return {
      accessCode: pieces[0],
      verifyCode: pieces[1]
    };
  }
  catch(err) {
    return errorResponse('Invalid credentials', 400);
  }
  */
};

// ==========================


var errorResponse = function(error, statusCode) {
  return {
    "error": {
      "text": error,
      "statusCode": statusCode
    }
  }; 
};

var getGlobalNodeFromRef = function(globalRef, ewd) {
  // returns a GlobalNode instance from the TMP pointer returned by VistA RPCs
  var gloRef = globalRef.substr(1);
  var pieces = gloRef.split('(');
  var globalName = pieces[0];
  var subs = gloRef.substr(globalName.length);
  subs = '[' + subs.substr(1);
  subs = subs.slice(0,-1) + ']';
  var subscripts = JSON.parse(subs);
  return new ewd.mumps.GlobalNode(globalName, subscripts);
};

var getJSONFromVPR = function(tmpNode, ewd) {

  var isSubNode = function(signature, currentArray) {
    var match = true;
    for (var i = 0; i < signature.length; i++) {
      if (signature[i].toString() !== currentArray[i].toString()) {
        match = false;
        break;
      }
    }
    return match;
  };

  var node = {
    global: tmpNode._globalName,
    subscripts: tmpNode._subscripts
  };

  var string = '';
  var ok = true;
  do {
    node = ewd.db.next_node(node);
    if (node.defined !== 0) {
      if (isSubNode(subscripts, node.subscripts)) {
        string = string + node.data;
      }
      else {
        ok = false;
      }
    }
    else {
      ok = false;
    }
  } while (ok);
  
  tmpNode._delete();
  
  var results = JSON.parse(string);
  return results;
};

var VistALogin = function(accessCode, verifyCode, ewd) {
  var ok = ewd.mumps.function('login^ZZCPCR00', accessCode, verifyCode);
  if (ok === '') {
    var temp = new ewd.mumps.GlobalNode('CacheTempEWD', [process.pid]);
    var results = temp._getDocument(0, false);
    temp._delete();
    return {
      error: false,
      data: results
    };
  }
  else{
    return {error: ok};
  }
};

module.exports = {

  errorResponse: errorResponse,

  authenticate: function(ewd) {
    var statusCode = 401;
    token = ewd.query['rest_auth'];
    if (!token) {
      // no token supplied
      return errorResponse('Failed authentication (1)', statusCode);
    }
    else if (token === '') {
      // token supplied was empty string
      return errorResponse('Failed authentication (2)', statusCode);
    }
    else {
      var session = ewd.util.getSession(token);
      if (session === '') {
        // token wasn't recognised or session timed out
        return errorResponse('Failed authentication (3)', statusCode);
      }
      else {
        ewd.util.updateSessionExpiry({
          sessid: session.$('ewd_sessid')._value
        });
        return {
          ok: true,
          session: session
        }
      }
    }
  },

  loginStatus: function(session) {
    var statusCode=401;
    if (session.$('VistA').$('DUZ')._value === '') return errorResponse('Failed authentication (4)', statusCode);
    if (session.$('cipherKey')._value !== '') return errorResponse('Failed authentication (5)', statusCode);
    return {ok: true};
  },

  initiate: function(appName, ewd) {
    var session = ewd.util.createNewSession(appName, 1200);
    var token = session.$('ewd_token')._value;
    var key = ewd.util.createToken();
    session.$('cipherKey')._value = key;
    return {
      Authorization: token,
      key: key
    };
  },

  login: function(ewd, session) {
    var sessid = session.$('ewd_sessid')._value;
    var errorStatusCode = 400;
    var key = session.$('cipherKey')._value;
    if (key === '') {
      ewd.util.deleteSession(sessid);
      return errorResponse('No key available', errorStatusCode);
    }
    var credentials = decryptCredentials(ewd.query.credentials, key);
    //console.log('credentials: ' + JSON.stringify(credentials));
    if (credentials.error) {
      ewd.util.deleteSession(sessid);
      return errorResponse(credentials.error, errorStatusCode);
    }
    if (!credentials.accessCode || credentials.accessCode === '') {
      ewd.util.deleteSession(sessid);
      return errorResponse('Missing Access Code', errorStatusCode);
    }
    if (!credentials.verifyCode || credentials.verifyCode === '') {
      ewd.util.deleteSession(sessid);
      return errorResponse('Missing Verify Code', errorStatusCode);
    }
    // ****************************
    var results = VistALogin(credentials.accessCode, credentials.verifyCode, ewd);
    // ****************************

    if (results.error) {
      ewd.util.deleteSession(sessid);
      return errorResponse(results.error, errorStatusCode);
    }
    else {
      // logged in
      session.$('cipherKey')._delete();
      session.$('VistA')._setDocument(results.data);
      return results.data;
    }
  },

  ddrLister: function(params, ewd) {
    var paramsObj = {
      FLAGS: 'PB',
      PART: '',
      XREF: '#'
    };
    for (var name in params) {
      paramsObj[name.toUpperCase()] = params[name];
    }
    var fields = '';
    var sc = '';
	var value;
	var fieldNames = ['IEN'];
	for (name in params.fields) {
		value = params.fields[name];
		fieldNames.push(name);
		fields = fields + sc + value;
		sc = ';'
	}
    paramsObj.FIELDS = fields;
    var temp = new ewd.mumps.GlobalNode('CacheTempEWD', [process.pid]);
    temp._delete();
    temp._setDocument(paramsObj, true);
    var gloRef = ewd.mumps.function('ddrLister^ZZCPCR00');
    var tmpNode = getGlobalNodeFromRef(gloRef, ewd);
    var results = {
      data: []
    };
    var error = false;
    var row;
	var rowObj;
	var i;
    tmpNode._forEachSubNode(function(data, node) {
      if (data === '[BEGIN_diERRORS]') {
        results.data = [];
        error = true;
      }
      else if (data !== '[BEGIN_diDATA]' && data !== '[END_diDATA]' && data !== '[END_diERRORS]') {
        row = data.split('^');
		rowObj = {};
		for (i = 0; i < row.length; i++) {
			fieldName = fieldNames[i] || i.toString();
			rowObj[fieldName] = row[i];
		}
        results.data.push(rowObj);
      }
    });
    if (error) return {
      error: JSON.stringify(results.data)
    };
    return results;
  },
  
  // DDR LISTER per joel's requirements
  ddrLister2: function(params, ewd) {
    var paramsObj = {
      FLAGS: 'IP',
      PART: '',
      XREF: '#'
    };
    for (var name in params) {
      paramsObj[name.toUpperCase()] = params[name];
    }
    paramsObj.FIELDS = params.FIELDS;

    var temp = new ewd.mumps.GlobalNode('CacheTempEWD', [process.pid]);
    temp._delete();
    temp._setDocument(paramsObj, true);
    var gloRef = ewd.mumps.function('ddrLister^ZZCPCR00');
    var tmpNode = getGlobalNodeFromRef(gloRef, ewd);
    var results = {
      data: []
    };
    var error = false;
    var row;
	var rowObj;
	var i;
    tmpNode._forEachSubNode(function(data, node) {
      if (data === '[BEGIN_diERRORS]') {
        results.data = [];
        error = true;
      }
      else if (data !== '[BEGIN_diDATA]' && data !== '[END_diDATA]' && data !== '[END_diERRORS]') {
        results.data.push(data);
      }
    });
    if (error) return {
      error: JSON.stringify(results.data)
    };
    return results;
  },
  
	ddrGetsEntry: function(params, ewd) {
		var file = params.file || '';
		var ienArray = params.iens || [];
		var field = params.field || '*';
		var flags = params.flags || 'IEN';
		var iens = '';
		var comma = ',';
		for (var i = 0; i < ienArray.length; i++) {
			iens = iens + ienArray[i] + comma;
		}
		
		//return { "file": file, "iens": iens, "field": field, "flags": flags };
		var status = ewd.mumps.function('ddrGetsEntry^ZZCPCR00', file, iens, field, flags);
		var temp = new ewd.mumps.GlobalNode('CacheTempEWD', [process.pid]);
		var results = temp._getDocument(0, false);
		temp._delete();
		
		//return { result: results, iens: iens };
		if (results.hasOwnProperty(iens)) {
			return results[iens];
		}
		else {
			return {};
		}
	},

	getNotesWithText: function(params, session, ewd) {
		params.reportsTabName = "OR_PN:PROGRESS NOTES~TIUPRG;ORDV04;15;";
		return this.runReportsTabRpc(params, session, ewd);
	},
	
	getImagingOrderTypes: function(params, session, ewd) {
		params.rpcName = "ORWDRA32 IMTYPSEL";
		params.rpcArgs = [];
		
		return this.runRpc(params, session, ewd);
	},
	
	getHospitalLocations: function(params, session, ewd) {
		params.rpcName = "ORWU1 NEWLOC";
		params.rpcArgs = [];
		// clean args 
		var target = "";
		var direction = "1";
		if (params.target != undefined && params.target != "") {
			target = params.target.toUpperCase();
		}
		if (params.direction != undefined && params.direction != "") {
			direction = params.direction;
		}

		params.rpcArgs.push({type: "LITERAL", value: target});
		params.rpcArgs.push({type: "LITERAL", value: direction});
		
		return this.runRpc(params, session, ewd);
	},
	
	getAllergies: function(params, session, ewd) {
		params.reportsTabName = "OR_BADR:ALLERGIES~ADR;ORDV01;73;";
		var reportsTabAllergies = this.toAllergiesFromReport(this.runReportsTabRpc(params, session, ewd));
		
		params.rpcName = "ORQQAL LIST";
		params.rpcArgs = [{type: "LITERAL", value: params.patientId}];
		var coverResponse = this.runRpc(params, session, ewd);
		var coverSheetAllergies = this.toAllergiesFromCover(coverResponse);
		
		var coverIds = this.toAllergyIdsFromCover(coverResponse);
		
		var supplemented = [];
		for (var i = 0; i < coverIds.length; i++) {
			if (reportsTabAllergies.hasOwnProperty(coverIds[i])) { // building allergy ids from cover sheet response so don't need to check it has the ID again
				reportsTabAllergies[coverIds[i]].reactions = coverSheetAllergies[coverIds[i]].reactions; // supplementing reactions from cover
				supplemented.push(reportsTabAllergies[coverIds[i]]);
			}
		}
		
		return supplemented;
	},
	
	toAllergyIdsFromCover: function(coverSheetResponse) {
		var result = [];
		var lines = [];
		
		// getDocument for global array result type turns lines in to object property names - just copy them over to a simple array
		// e.g. { 1: "line 1", 2: "line 2", etc... }  -> want this: [ "line 1", "line 2", etc... ]
		var currentIdx = 1;
		while (coverSheetResponse.value.hasOwnProperty(currentIdx.toString())) {
			lines.push(coverSheetResponse.value[currentIdx.toString()]);
			currentIdx++;
		}

		for (var i = 0; i < lines.length; i++) {
			result.push(lines[i].split("^")[0]);
		}
		
		return result;
	},
	
	toAllergiesFromCover: function(coverSheetResponse) {
		var result = { };
		var lines = [];
		
		// getDocument for global array result type turns lines in to object property names - just copy them over to a simple array
		// e.g. { 1: "line 1", 2: "line 2", etc... }  -> want this: [ "line 1", "line 2", etc... ]
		var currentIdx = 1;
		while (coverSheetResponse.value.hasOwnProperty(currentIdx.toString())) {
			lines.push(coverSheetResponse.value[currentIdx.toString()]);
			currentIdx++;
		}

		for (var i = 0; i < lines.length; i++) {
			var pieces = lines[i].split("^");
			var newAllergy = {};
			newAllergy.id = pieces[0];
			newAllergy.allergenName = pieces[1];
			newAllergy.reactions = [{ name: pieces[3] }];
			result[newAllergy.id] = newAllergy;
		}
		
		return result;
	},
	
	toAllergiesFromReport: function(reportsTabResponse) {
		var result = { };
		var lines = [];
		
		// getDocument for global array result type turns lines in to object property names - just copy them over to a simple array
		// e.g. { 1: "line 1", 2: "line 2", etc... }  -> want this: [ "line 1", "line 2", etc... ]
		var currentIdx = 1;
		while (reportsTabResponse.result.hasOwnProperty(currentIdx.toString())) {
			lines.push(reportsTabResponse.result[currentIdx.toString()]);
			currentIdx++;
		}
		
		for (var i = 0; i < lines.length; i++) {
			var newAllergy = { };
			var curObj = lines[i].WP;
			
			var facilityStr = curObj["1"]; //"1^CAMP MASTER;500"
			var allergenStr = curObj["2"]; //"2^CHOCOLATE"
			var allergenTypeStr = curObj["3"]; //"3^DRUG, FOOD"
			var timestampStr = curObj["4"]; //"4^12/17/2007 14:56"
			var typeStr = curObj["5"]; //"5^HISTORICAL"
			// TODO - comment is in curObj["6"] somehow...
			var idStr = curObj["7"]; //"7^972"
			
			if (undefined != facilityStr && facilityStr != "") {
				newAllergy.facility = { id: (facilityStr.split("^")[1]).split(";")[1], name: (facilityStr.split("^")[1]).split(";")[0] };
			}
			if (undefined != allergenStr && allergenStr != "") {
				newAllergy.allergenName = allergenStr.split("^")[1];
			}
			if (undefined != allergenTypeStr && allergenTypeStr != "") {
				newAllergy.allergenType = allergenTypeStr.split("^")[1];
			}
			if (undefined != timestampStr && timestampStr != "") {
				newAllergy.timestamp = timestampStr.split("^")[1];
			}
			if (undefined != typeStr && typeStr != "") {
				newAllergy.type = { name: typeStr.split("^")[1], category: "Allergies and Adverse Reactions" };
			}
			if (undefined != idStr && idStr != "") {
				newAllergy.id = idStr.split("^")[1];
			}
			
			result[newAllergy.id] = newAllergy;
		}
		
		return result;
	},
	
	getChemHemReports: function(params, session, ewd) {
		//return chemHemLib.getChemHemReports(this, params, session, ewd);
		// swap patient ID for lab data file ID
		var lrdfn = this.getLrdfnFromDfn(params.patientId, session, ewd);
		params.lrdfn = lrdfn;
		// add time component on toDate if not specified
		if (params.toDate.indexOf('.') < 0) {
			params.toDate = params.toDate + ".235959";
		}
		// get specimens via DDR for supplementing RPCs
		var specimens = this.getChemHemSpecimens(params, session, ewd);
		
		// now make calls for reports for each specimen
		params.date = params.toDate; // set this the first time to the toDate arg
		//var reports = {};
		var finalResults = [];
		var fetchedReportsCount = 0;
		while (fetchedReportsCount < specimens.count) { // fetch a report for each specimen via RPC
			var currentReport = this.getChemHemReport(params, session, ewd);
			fetchedReportsCount++;
			params.date = currentReport.timestamp;
			
			if (!specimens.hasOwnProperty(currentReport.id)) {
				continue;
			};
			var associatedSpecimen = specimens[currentReport.id];
			
			// supplement report with specimen data
			currentReport.id = associatedSpecimen.id; // overwrite composite ID with ID from specimen
			currentReport.facility = associatedSpecimen.facility;
			currentReport.specimen = associatedSpecimen;
			currentReport.timestamp = associatedSpecimen.reportDate;
			finalResults.push(currentReport);
			// end supplement
		}
		
		return finalResults;
	},
	
	getChemHemReport: function(params, session, ewd) {
		params.rpcName = "ORWLRR INTERIMG";
		params.rpcArgs = [];
		
		params.rpcArgs.push({type: "LITERAL", value: params.patientId});
		params.rpcArgs.push({type: "LITERAL", value: params.date});
		params.rpcArgs.push({type: "LITERAL", value: "1"});
		params.rpcArgs.push({type: "LITERAL", value: "1"});
		
		var results = this.runRpc(params, session, ewd);
        
		// TODO - consider auto-detecting this type of thing in runRpc...
		// ORWLRR INTERIMG returns a global array reference - need to get it after calling RPC
		var resultRef = results.value;
		var resultGlo = getGlobalNodeFromRef(resultRef, ewd);
		results = resultGlo._getDocument();
		resultGlo._delete();
		
		return this.toChemHemReport(results);
	},
	
	toChemHemReport: function(rpcResult) {
		var result = {};
		
		var lines = [];
		
		// getDocument for global array result type turns lines in to object property names - just copy them over to a simple array
		// e.g. { 1: "line 1", 2: "line 2", etc... }  -> want this: [ "line 1", "line 2", etc... ]
		var currentIdx = 1;
		while (rpcResult.hasOwnProperty(currentIdx.toString())) {
			lines.push(rpcResult[currentIdx.toString()]);
			currentIdx++;
		}
		// done copy to simple array
		
		var fields = lines[0].split("^");
		
		if (fields[1] != "CH" || lines[1].length == 1) {
			return { msg: "NOT CH" };
		}
		
		var noTests = Number(fields[0]);
		result.id = fields[2] + "^" + fields[5];
		result.timestamp = fields[2];
		result.specimen = { };
		result.specimen.collectionDate = fields[2];
		result.specimen.name = fields[4];
		result.specimen.accessionNumber = fields[5];
		result.author = { name: fields[6] };
		
		result.labResults = [];
		var i = 1;
		for (i = 1; i <= noTests; i++) {
			var labResult = {};
			fields = lines[i].split("^");
			labResult.labTest = {};
			labResult.labTest.id = fields[0];
			labResult.labTest.name = fields[1];
			labResult.value = fields[2].trim();
			labResult.boundaryStatus = fields[3];
			labResult.labTest.units = fields[4].trim();
			labResult.labTest.refRange = fields[5];
			
			result.labResults.push(labResult);
		}
		
		result.comment = "";;
		while (i < lines.length) {
			result.comment = result.comment + lines[i++].trim() + "\r\n";
		}
		
		return result;
	},
	
	getChemHemSpecimens: function(params, session, ewd) {
		params.FILE = "63.04";
		params.IENS = "," + params.lrdfn + ",";
		params.FIELDS = ".01;.03;.05E;.06;.08;.112E";
		params.FLAGS = "IP";
		params.XREF = "#";
		params.SCREEN = "S FD=" + params.fromDate + ",TD=" + params.toDate + ",CDT=$P(^(0),U,3) I CDT>=FD,CDT<TD";
		params.ID = "S X=$P(^(0),U,14) I X'= \"\" S Y=$P($G(^DIC(4,X,99)),U,1) D EN^DDIOL(Y)";

		var ddrResults = this.ddrLister2(params, ewd);

		if (!ddrResults.hasOwnProperty("data")) {
			return {};
		}
		return this.toChemHemSpecimens(ddrResults.data);
	},
	
	toChemHemSpecimens: function(ddrListerResult) {
		var result = {};
		result.count = ddrListerResult.length;

		for (var i = 0; i < ddrListerResult.length; i++) {
			var pieces = ddrListerResult[i].split('^');
			var current = {};
			current.id = pieces[0];
			current.reportDate = pieces[2]; // DATE!!!
			current.collectionDate = pieces[1]; // DATE!!!
			
			current.name = pieces[3];
			current.accessionNumber = pieces[4];
			current.site = pieces[5];
			if (pieces.length > 6) {
				current.facility = { id: pieces[7], name: pieces[6] };
			}
			
			var key = pieces[1] + "^" + pieces[4];
			result[key] = current;
		}
		
		return result;
	},
	
	getLrdfnFromDfn: function(dfn, session, ewd) {
		return this.mEval("$G(^DPT(" + dfn + ",\"LR\"))", session, ewd);
	},
	
	// FYI: RAPTOR is already receiving the patient ID with the worklist. This extra call to VistA is unnecessary
	getPatientIDFromTrackingID: function(params, session, ewd) {
		return { result: this.mEval("$P(^RAO(75.1," + params.ien + ",0),U,1)", session, ewd) };
	},
	
	// call to vista works
	getProblemList: function(params, session, ewd) {
		params.rpcName = "ORQQPL PROBLEM LIST";
		params.rpcArgs = [];
        
		params.rpcArgs.push({type: "LITERAL", value: params.patientId});
        params.rpcArgs.push({type: "LITERAL", value: "B"});
		
        return this.runRpc(params, session, ewd);
	},
	
	// call to vista works
	getVisits: function(params, session, ewd) {
        params.rpcName = "ORWCV VST";
		params.rpcArgs = [];
		
		var patientId = params.patientId;
		var fromDate = params.fromDate; 
		var toDate = params.toDate;
        
		params.rpcArgs.push({type: "LITERAL", value: patientId});
        params.rpcArgs.push({type: "LITERAL", value: fromDate});
        params.rpcArgs.push({type: "LITERAL", value: toDate});
        params.rpcArgs.push({type: "LITERAL", value: '1'});
		
        return this.runRpc(params, session, ewd);
	},
	
	// call to vista works
	getVitalSigns: function(params, session, ewd) {
		params.reportsTabName = "OR_VS:VITAL SIGNS~VS;ORDV04;47;";
		return this.runReportsTabRpc(params, session, ewd);
	},
	
	// call to vista works
	getRadiologyReports: function(params, session, ewd) {
		params.reportsTabName = "OR_R18:IMAGING~RIM;ORDV08;0;";
		return this.runReportsTabRpc(params, session, ewd);
	},

	signNote: function(params, session, ewd) {
		var encyptedSig = this.encryptRpcParameter(params.eSig, session, ewd);
		
		params.rpcName = "TIU SIGN RECORD";
		params.rpcArgs = [];
		
		params.rpcArgs.push({ type: "LITERAL", value: params.noteIen });
		params.rpcArgs.push({ type: "LITERAL", value: encyptedSig });
		
		return this.runRpc(params, session, ewd);
	},
	
	isValidESig: function(params, session, ewd) {
		params.rpcName = "ORWU VALIDSIG";
		params.rpcArgs = [ { type: "LITERAL", value: this.encryptRpcParameter(params.eSig, session, ewd) } ];
		
		return this.runRpc(params, session, ewd);
	},
	
	
	
	
	
	// helpers for running RPCs below
	runRpc: function(params, session, ewd) {
		// TODO - how to handle issues? throw exception? return JSON obj with error message?
        var gloRef = new ewd.mumps.GlobalNode('TMP', [process.pid]);
        var vista = session.$('VistA');
        var data = {
            name : params.rpcName,
            duz: vista.$('DUZ')._value,
            dt: vista.$('DT')._value,
            division: "",
            context: "",
            input: params.rpcArgs
        };
        gloRef._setDocument(data, true, 1);
        
        var status = ewd.mumps.function("RPCEXECUTE^RPCWRP", '^TMP(' + process.pid + ')') ;
        var resultsNode = gloRef.$('result');
        var results = resultsNode._getDocument();
		gloRef._delete();
		return results;
	},
	
	runReportsTabRpc: function(params, session, ewd) {
		// params => { reportsTabName:"OR_VS:VITAL SIGNS~VS;ORDV04;47;", patientId: PID }
		// params => { reportsTabName:"OR_VS:VITAL SIGNS~VS;ORDV04;47;", patientId: PID, fromDate: "20150704", toDate:"20150731", nRpts: 25 }
        
		var fromDate = "0";
		var toDate = "0";
		var nRpts = "0";
		
		// setup date and nrpts so they have everything for RPC builder below
		if (params.hasOwnProperty("fromDate")) {
			fromDate = params.fromDate;
		}
		if (params.hasOwnProperty("toDate")) {
			toDate = params.toDate;
		}
		if (params.hasOwnProperty("nRpts")) {
			nRpts = params.nRpts;
		}

		var gloRef = new ewd.mumps.GlobalNode('TMP', [process.pid]);
        var vista = session.$('VistA');
        var data = {
            name : "ORWRP REPORT TEXT",
            duz: vista.$('DUZ')._value,
            dt: vista.$('DT')._value,
            division: "500",
            context: "",
            input: [
              {type: "LITERAL", value: params.patientId},
              {type: "LITERAL", value: (params.reportsTabName + nRpts)},
              {type: "LITERAL", value: ""},
              {type: "LITERAL", value: (fromDate == "0" ? "50000" : "")}, // if specifying fromDate then set to empty string, otherwise 50000
              {type: "LITERAL", value: ""},
              {type: "LITERAL", value: fromDate},
              {type: "LITERAL", value: toDate},
            ]
        };
        gloRef._setDocument(data, true, 1);
        
        var status = ewd.mumps.function("RPCEXECUTE^RPCWRP", '^TMP(' + process.pid + ')') ;
        var resultsNode = gloRef.$('result');
        var results = resultsNode._getDocument();
		gloRef._delete();
        
		// the reports tab RPC returns a reference to where it stored the data - need to get it!! (and delete it)
		var resultRef = results.value;
		var resultGlo = getGlobalNodeFromRef(resultRef, ewd);
		results = resultGlo._getDocument();
		resultGlo._delete();
		
		return {result: results, pid: process.pid};
	},
	
	mEval : function(arg, session, ewd) {
		return ewd.mumps.function("EVAL^RPCWRP", arg);
	},
		

	encryptRpcParameter: function(arg, session, ewd) {
		return { result: ewd.mumps.function("ENCRYP^XUSRB1", arg) };
	}
};