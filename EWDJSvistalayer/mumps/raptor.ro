Cache for UNIX^INT^Export of Raptor M routines^~Format=Cache.S~^RAW
%RO on 19 Aug 2015   8:23 AM
RPCWRP^INT^1^^
RPCWRP ; NST - VistA RPC wrapper ; 02/25/2014 11:56PM
 ;;
 ;;    Author: Nikolay Topalov
 ;;
 ;;    Copyright 2014 Nikolay Topalov
 ;;
 ;;    Licensed under the Apache License, Version 2.0 (the "License");
 ;;    you may not use this file except in compliance with the License.
 ;;    You may obtain a copy of the License at
 ;;    http://www.apache.org/licenses/LICENSE-2.0
 ;;    Unless required by applicable law or agreed to in writing, software
 ;;    distributed under the License is distributed on an "AS IS" BASIS,
 ;;    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;;    See the License for the specific language governing permissions and
 ;;    limitations under the License.
 ;;
 Q
 ;
QUOTESTEST(ARGONE,ARGTWO,ARGTHREE)
 Q "OK"
HELLOWORLD()
 Q "HELLO SUCKA!"
GETJOB()
 Q $J
RPCEXECUTE(TMP,DT) ;
 ;
 ; Execute an RPC based on paramaters provided in TMP reference global
 ;
 ; Input parameter
 ; ================
 ;
 ; TMP is a reference to a global with nodes. e.g.,  ^TMP($J)
 ;
 ;   ,"name")      NAME (#8994, .01)
 ;   ,"version")   VERSION (#8994, .09)
 ;   ,"use") = L|R
 ;   ,"input",n,"type")   PARAMETER TYPE (#8994.02, #02)
 ;   ,"input",n,"value")  input parameter value
 ;      e.g.
 ;      ,"input",n,"type")="LITERAL"
 ;      ,"input",n,"value")="abc"
 ;
 ;      ,"input",n,"type")="REFERENCE"
 ;      ,"input",n,"value")="^ABC"
 ;
 ;      ,"input",n,"type")="LIST"
 ;      ,"input",n,"value",m1)="list1"
 ;      ,"input",n,"value",m2,k1)="list21"
 ;      ,"input",n,"value",m2,k2)="list22"
 ;         
 ;          where m1, m2, k1, k2 are numbers or strings
 ;     
 ; Output value
 ; ==============
 ; The RPC output is in  @TMP@("result")
 ;  e.g., ,"result","type")="SINGLE VALUE"
 ;                  "value")="Hello World!"
 ;                
 ; Return {"success": result, "message" : message }
 ;    result 1 - success
 ;           0 - error
 ;
 k (TMP,DT)
 N rpc,pRpc,tArgs,tCnt,tI,tOut,tResult,X
 N XWBAPVER,DUZ,DT
 ;
 S U=$G(U,"^")  ; set default to "^"
 ;
 S pRpc("name")=$G(@TMP@("name"))
 Q:pRpc("name")="" $$error(-1,"RPC name is missing")
 ;
 S rpc("ien")=$O(^XWB(8994,"B",pRpc("name"),""))
 Q:'rpc("ien") $$error(-2,"Undefined RPC ["_pRpc("name")_"]")
 ;
 S XWBAPVER=$G(@TMP@("version"))
 S pRpc("use")=$G(@TMP@("use"))
 S pRpc("context")=$G(@TMP@("context"))
 S pRpc("duz")=$G(@TMP@("duz"))
 S pRpc("division")=$G(@TMP@("division"))
 ; Set DUZ
 S DUZ=pRpc("duz")
 S:'$D(DUZ(2)) DUZ(2)=pRpc("division")
 S:DUZ DUZ(0)=$P(^VA(200,DUZ,0),U,4)
 S DT=$G(@TMP@("dt"))
 ;
 S X=$G(^XWB(8994,rpc("ien"),0)) ;e.g., XWB EGCHO STRING^ECHO1^XWBZ1^1^R
 S rpc("routineTag")=$P(X,"^",2)
 S rpc("routineName")=$P(X,"^",3)
 Q:rpc("routineName") $$error(-4,"Undefined routine name for RPC ["_pRpc("name")_"]")
 ;
 ; 1=SINGLE VALUE; 2=ARRAY; 3=WORD PROCESSING; 4=GLOBAL ARRAY; 5=GLOBAL INSTANCE
 S rpc("resultType")=$P(X,"^",4)
 S rpc("resultWrapOn")=$P(X,"^",8)
 ;
 ; is the RPC available
 D CKRPC^XWBLIB(.tOut,pRpc("name"),pRpc("use"),XWBAPVER)
 Q:'tOut $$error(-3,"RPC ["_pRpc("name")_"] cannot be run at this time.")
 ;
 S X=$$CHKPRMIT(pRpc("name"),pRpc("duz"),pRpc("context"))
 Q:X'="" $$error(-4,"RPC ["_pRpc("name")_"] is not allowed to be run: "_X)
 ;
 S X=$$buildArguments(.tArgs,rpc("ien"),TMP)  ; build RPC arguments list - tArgs
 M ^TMP($J,"DEBUG","buildArgs","tArgs")=tArgs
 S ^TMP($J,"DEBUG","buildArgs","X")=X
 Q:X<0 $$error($P(X,U),$P(X,U,2)) ; error building arguments list
 ;
 ; now, prepare the arguments for the final call
 ; it is outside of the $$buildArgumets so we can newed the individual parameters
 S (tI,tCnt)=""
 F  S tI=$O(tArgs(tI)) Q:tI=""  F  S tCnt=$O(tArgs(tI,tCnt)) Q:tCnt=""  N @("tA"_tI) X tArgs(tI,tCnt)  ; set/merge actions
 S ^TMP($J,"DEBUG","tA1")="The value for tA1: "_$G(tA1)
 ;
 S X="D "_rpc("routineTag")_"^"_rpc("routineName")_"(.tResult"_$S(tArgs="":"",1:","_tArgs)_")"
 S DIC(0)="" ; JAM 2014/9/5 - some obscure problem with LAYGO^XUA4A7
 S ^TMP($J,"DEBUG","X")=X
 S ^TMP($J,"DEBUG","tArgs")=tArgs
 X X  ; execute the routine
 M @TMP@("result","value")=tResult
 S @TMP@("result","type")=$$EXTERNAL^DILFD(8994,.04,,rpc("resultType"))
 S trash=$$success()
 Q "OK"
 ;
 ;
isInputRequired(pIEN,pSeqIEN) ; is input RPC parameter is required
 ; pIEN - RPC IEN in file #8994
 ; pSeqIEN - Input parameter IEN in multiple file #8994.02
 ;
 Q $P(^XWB(8994,pIEN,2,pSeqIEN,0),U,4)=1
 ;
buildArguments(out,pIEN,TMP) ;Build RPC argument list
 ;
 ; Return values
 ; =============
 ; Success 1
 ; Error   -n^error message
 ;
 ; out array with arguments
 N tCnt,tError,tIEN,tI,tII,tRequired,tParam,tIndexSeq,X
 ;
 S tI=0
 S tII=""
 S tCnt=0
 ;
 K out
 S out=""
 S tError=0
 S tIndexSeq=$D(^XWB(8994,pIEN,2,"PARAMSEQ"))  ; is the cross-reference defined
 S tParam=$S(tIndexSeq:"^XWB(8994,pIEN,2,""PARAMSEQ"")",1:"^XWB(8994,pIEN,2)")
 ;
 S ^TMP($J,"DEBUG","ARGS","tParam")=tParam
 M ^TMP($J,"DEBUG","ARGS","TMP")=TMP
 S count=0
 ;I $D(^XWB(8994,pIEN,2)) F  S tI=$O(@tParam@(tI)) Q:('tI)!(tError)  D
 ;. S count=count+1
 ;. S ^TMP($J,"DEBUG","ARGS","tI",count)=tI
 ;. S tII=$O(@TMP@("input",tII))
 ;. S ^TMP($J,"DEBUG","ARGS","tII",count)=tII
 ;. S tIEN=$S(tIndexSeq:$O(@tParam@(tI,"")),1:tI)  ; get the IEN of the input parameter
 ;. S tRequired=$$isInputRequired(pIEN,tIEN)
 ;. I tRequired,'$D(@TMP@("input",tII,"value")) S tError="-5^Required input paramater is missing." Q
 ;. I '$D(@TMP@("input",tII,"value")) S out=out_"," Q
 ;. I $D(@TMP@("input",tII,"value"))=1 D  Q
 ;. . S out=out_"tA"_tI_","   ; add the argument
 ;. . I $$UP^XLFSTR($G(@TMP@("input",tII,"type")))="REFERENCE" D
 ;. . . S tCnt=tCnt+1,out(tI,tCnt)="S tA"_tI_"=@@TMP@(""input"","_tII_",""value"")"  ; set it
 ;. . . Q
 ;. . E  S tCnt=tCnt+1,out(tI,tCnt)="S tA"_tI_"=@TMP@(""input"","_tII_",""value"")"  ; set it as action for later
 ;. . Q
 ;. ; list/array
 ;. S out=out_".tA"_tI_","
 ;. S tCnt=tCnt+1,out(tI,tCnt)="M tA"_tI_"=@TMP@(""input"","_tII_",""value"")"  ; merge it
 ;. Q
 ;I '$D(^XWB(8994,pIEN,2)) F  S tII=$O(@TMP@("input",tII)) Q:('tII)!(tError)  D
 F  S tII=$O(@TMP@("input",tII)) Q:('tII)!(tError)  D
 . S count=count+1
 . S ^TMP($J,"DEBUG","ARGS","tII",count)=tII
 . S tIEN=tII  ; get the IEN of the input parameter
 . I '$D(@TMP@("input",tII,"value")) S out=out_"," Q
 . I $D(@TMP@("input",tII,"value"))=1 D  Q
 . . S out=out_"tA"_tII_","   ; add the argument
 . . S ^TMP($J,"DEBUG","MSG",count,1)="LINE 180"
 . . I $$UP^XLFSTR($G(@TMP@("input",tII,"type")))="REFERENCE" D
 . . . S ^TMP($J,"DEBUG","MSG",count,2)="LINE 182"
 . . . S tCnt=tCnt+1,out(tII,tCnt)="S tA"_tII_"=@@TMP@(""input"","_tII_",""value"")"  ; set it
 . . . S ^TMP($J,"DEBUG","MSG",count,3)="LINE 184"
 . . . Q
 . . E  S tCnt=tCnt+1,out(tII,tCnt)="S tA"_tII_"=@TMP@(""input"","_tII_",""value"")"  ; set it as action for later
 . . Q
 . ; list/array
 . S ^TMP($J,"DEBUG","MSG",count,4)="LINE 189 - outside if/else"
 . S out=out_".tA"_tII_","
 . S tCnt=tCnt+1,out(tII,tCnt)="M tA"_tII_"=@TMP@(""input"","_tII_",""value"")"  ; merge it
 . Q
 ;
 S ^TMP($J,"DEBUG","MSG","exit")="outside for loop"
 Q:tError tError
 S out=$E(out,1,$L(out)-1)
 Q 1
 ;
formatResult(code,message) ; return JSON formatted result
 S ^TMP($J,"RPCEXECUTE","result")=code_U_message
 Q "OK"
 ;Q "{""success"": "_code_", ""message"": """_$S($TR(message," ","")="":"",1:message)_"""}"
 ;
error(code,message) ;
 Q $$formatResult(0,code_" "_message)
 ;
success(code,message) ;
 Q $$formatResult(1,$G(code)_" "_$G(message))
 ;
 ; Is RPC pertmited to run in a context?
CHKPRMIT(pRPCName,pUser,pContext) ;checks to see if remote procedure is permited to run
 ;Input:  pRPCName - Remote procedure to check
 ;        pUser    - User
 ;        pContext - RPC Context
 Q:$$KCHK^XUSRB("XUPROGMODE",pUser) ""  ; User has programmer key
 N result,X
 N XQMES
 S U=$G(U,"^")
 S result="" ;Return XWBSEC="" if OK to run RPC
 ;
 ;In the beginning, when no DUZ is defined and no context exist,
 ;setup default signon context
 S:'$G(pUser) pUser=0,pContext="XUS SIGNON"   ;set up default context
 ;
 ;These RPC's are allowed in any context, so we can just quit
 S X="^XWB IM HERE^XWB CREATE CONTEXT^XWB RPC LIST^XWB IS RPC AVAILABLE^XUS GET USER INFO^XUS GET TOKEN^XUS SET VISITOR^"
 S X=X_"XUS KAAJEE GET USER INFO^XUS KAAJEE LOGOUT^"  ; VistALink RPC's that are always allowed.
 I X[(U_pRPCName_U) Q result
 ;
 ;
 ;If in Signon context, only allow XUS and XWB rpc's
 I $G(pContext)="XUS SIGNON","^XUS^XWB^"'[(U_$E(pRPCName,1,3)_U) Q "Application context has not been created!"
 ;XQCS allows all users access to the XUS SIGNON context.
 ;Also to any context in the XUCOMMAND menu.
 ;
 I $G(pContext)="" Q "Application context has not been created!"
 ;
 S X=$$CHK^XQCS(pUser,pContext,pRPCName)         ;do the check
 S:'X result=X
 Q result
 ;
arrayToJSON(name)
 n subscripts
 i '$d(@name) QUIT "[]"
 QUIT $$walkArray("",name)
 ;
walkArray(json,name,subscripts)
 ;
 n allNumeric,arrComma,brace,comma,count,cr,dd,i,no,numsub,dblquot,quot
 n ref,sub,subNo,subscripts1,type,valquot,value,xref,zobj
 ;
 s cr=$c(13,10),comma=","
 s (dblquot,valquot)=""""
 s dd=$d(@name)
 i dd=1!(dd=11) d  i dd=1 QUIT json
 . s value=@name
 . i value'[">" q
 . s json=$$walkArray(json,value,.subscripts)
 s ref=name_"("
 s no=$o(subscripts(""),-1)
 i no>0 f i=1:1:no d
 . s quot=""""
 . i subscripts(i)?."-"1N.N s quot=""
 . s ref=ref_quot_subscripts(i)_quot_","
 s ref=ref_"sub)"
 s sub="",numsub=0,subNo=0,count=0
 s allNumeric=1
 f  s sub=$o(@ref) q:sub=""  d  q:'allNumeric
 . i sub'?1N.N s allNumeric=0
 . s count=count+1
 . i sub'=count s allNumeric=0
 ;i allNumeric,count=1 s allNumeric=0
 i allNumeric d
 . s json=json_"["
 e  d
 . s json=json_"{"
 s sub=""
 f  s sub=$o(@ref) q:sub=""  d
 . s subscripts(no+1)=sub
 . s subNo=subNo+1
 . s dd=$d(@ref)
 . i dd=1 d
 . . s value=@ref
 . . i 'allNumeric d
 . . . s json=json_""""_sub_""":"
 . . s type="literal"
 . . i $$numeric(value) s type="numeric"
 . . ;i value?1N.N s type="numeric"
 . . ;i value?1"-"1N.N s type="numeric"
 . . ;i value?1N.N1"."1N.N s type="numeric"
 . . ;i value?1"-"1N.N1"."1N.N s type="numeric"
 . . i value="true"!(value="false") s type="boolean"
 . . i $e(value,1)="{",$e(value,$l(value))="}" s type="variable"
 . . i $e(value,1,4)="<?= ",$e(value,$l(value)-2,$l(value))=" ?>" d
 . . . s type="variable"
 . . . s value=$e(value,5,$l(value)-3)
 . . i type="literal" s value=valquot_value_valquot
 . . d
 . . . s json=json_value_","
 . k subscripts1
 . m subscripts1=subscripts
 . i dd>9 d
 . . i sub?1N.N,allNumeric d
 . . . i subNo=1 d
 . . . . s numsub=1
 . . . . s json=$e(json,1,$l(json)-1)
 . . . . s json=json_"["
 . . e  d
 . . . s json=json_""""_sub_""":"
 . . s json=$$walkArray(json,name,.subscripts1)
 . . d
 . . . s json=json_","
 ;
 s json=$e(json,1,$l(json)-1)
 i allNumeric d
 . s json=json_"]"
 e  d
 . s json=json_"}"
 QUIT json ; exit!
 ;
numeric(value)
 i $e(value,1,9)="function(" QUIT 1
 i value?1"0."1N.N QUIT 1
 i $e(value,1)=0,$l(value)>1 QUIT 0
 i $e(value,1,2)="-0",$l(value)>2,$e(value,1,3)'="-0." QUIT 0
 i value?1N.N QUIT 1
 i value?1"-"1N.N QUIT 1
 i value?1N.N1"."1N.N QUIT 1
 i value?1"-"1N.N1"."1N.N QUIT 1
 i value?1"."1N.N QUIT 1
 i value?1"-."1N.N QUIT 1
 QUIT 0
 ;
zi
 n file,i
 zr
 s file="mumps1.txt"
 c file o file u file
 f i=1:1 r line zi line
 QUIT
 ;
zs
 zs ^RPCWRP
 QUIT
 ;
EVAL(arg) ;
 N result,X
 S $ZT="EVALERR"
 S X="S result="_arg
 X X
 QUIT result
 ;
KST(arg) ; Kill Symbol Table
 K:arg="password"
 Q "OK"
EVALERR ;
 QUIT "error in "_arg

ZZCPCR00^INT^1^^0^1
ZZCPCR00	;;node functions in vista
	;
gets(z)	;generic call to GETS^DIQ
	s ^cpc("g")=1
	n fieldName,fileName,fileNo,fields,fln,fn,ien,ienX,inputs,outputs,results,sf,sfCount,sfIen,sfLvl,sfName
	m inputs=^%zewdTemp($j,"inputs")
	k results
	s fileNo=$g(inputs("fileNo")) i 'fileNo q "no file supplied"
	s ien=$g(inputs("recordId")) i 'ien q "no record Id supplied"
	s fields=$g(inputs("fields")) i fields="" s fields="**" ;default is all fields,subfields and multiples
	s flags=$g(inputs("flags")) i flags="" s flags="RNIE" ;default is internal, external, filednames, no null results
	s ^cpc("g",fileNo,1)=$h
	s ienX=ien_","
	s fileName=$$validName($p($G(^DIC(fileNo,0)),"^",1))
	s outputs(fileName,"id")=ien
	d GETS^DIQ(fileNo,ienX,fields,flags,"results")
	d treeIt
	m ^%zewdTemp($j,"outputs")=outputs
	s ^cpc("g",fileNo,2)=$h
	;i fileNo=55 m ^cpc($j)=outputs
	q ""
getPatientSummary(z)	;call to LIST^DIC
	;?MAKE THIS GENERIC OR SPECIFIC
	;Do spefic to this call for now
	;s ^cpc("gps")=1
	n errors,results,outputs,DILOCKTM,DISYS,DT,DTIME,DUZ,IO,O,U
	D LIST^DIC(2,"",".01;.02;.033;.03IE;.1;.09","Q","","","","CN","","","results","errors")
	;results("DILIST",2,10)=24
	;results("DILIST","ID",10,.01)="DEMO,JOHN"
	;results("DILIST","ID",10,.02)="MALE"
	;results("DILIST","ID",10,.03,"E")="03/07/2011"
	;results("DILIST","ID",10,.03,"I")=3110307
	;results("DILIST","ID",10,.033)=58
	;results("DILIST","ID",10,.09)=""
	;results("DILIST","ID",10,.1)="3 WEST"
	f i="<10","10-20","20-30","30-40","40-50","50-60","60-70","70-80",">80" s outputs("ages",i,"total")=0
	s c=0,i="" f  s i=$o(results("DILIST","ID",i)) q:i=""  q:'i  d
	. s ien=results("DILIST",2,i)
	. s wardName=results("DILIST","ID",i,.1)
	. s name=results("DILIST","ID",i,.01)
	. s sex=results("DILIST","ID",i,.02)
	. s dateI=results("DILIST","ID",i,.03,"I")
	. s dateE=results("DILIST","ID",i,.03,"E")
	. s dateUK=$p(dateE,"/",2)_"/"_$p(dateE,"/",1)_"/"_$p(dateE,"/",3)
	. s age=results("DILIST","ID",i,.033)
	. s ssn=results("DILIST","ID",i,.09)
	. s outputs("wards",wardName,"total")=$g(outputs("wards",wardName,"total"))+1
	. ;s outputs("wards",wardName,"patients",outputs("wards",wardName,"total")-1)=ien
	. s outputs("wards",wardName,"patients",ien)=ien
	. s outputs("patients",ien,"id")=ien
	. s outputs("patients",ien,"name")=name
	. s outputs("patients",ien,"sex")=sex
	. s outputs("patients",ien,"DOB")=dateUK
	. s outputs("patients",ien,"SSN")=ssn
	. s ageR=$s(age<10:"<10",age<20:"10-20",age<30:"20-30",age<40:"30-40",age<50:"40-50",age<60:"50-60",age<70:"60-70",age<80:"70-80",1:">80")
	. s outputs("ages",ageR,"total")=outputs("ages",ageR,"total")+1
	. s outputs("ages",ageR,"patients",ien)=ien
	. s c=c+1
	m ^%zewdTemp($j,"outputs")=outputs
	s ^cpc("gps")=2
	Q ""
	;
trace(value) ;
 n n
 s n=$increment(^CacheTempTrace)
 s ^CacheTempTrace(n)=value
 QUIT
	;
login(accessCode,verifyCode)
 ;
 k (accessCode,verifyCode)
 n %,accver,DILOCKTM,displayPersonName,DISYS,%DT,DT,DTIME,DUZ,%H
 n checkRes,%I,I,IO,IOF,IOM,ION,IOS,IOSL,IOST,IOT,J,ok,personDuz,personName
 n POP,results,supervisor,termReason,U,user,V4WVCC,V4WCVMSG
 n X,XOPT,XPARSYS,XQVOL,XQXFLG,XUCI,XUDEV,XUENV,XUEOFF,XUEON
 n XUF,XUFAC,XUIOP,XUVOL,XWBSTATE,XWBTIME,Y
 ;
 s accessCode=$g(accessCode) i accessCode="" q "Missing Access Code"
 s verifyCode=$g(verifyCode) i verifyCode="" q "Missing Verify Code"
 d trace("login: ac="_accessCode_"; vc="_verifyCode)
 ;
 k results
 s U="^" d NOW^%DTC s DT=X
 s (IO,IO(0),IOF,IOM,ION,IOS,IOSL,IOST,IOT)="",POP=0
 s accver=accessCode_";"_verifyCode
 s accver=$$ENCRYP^XUSRB1(accver)
 d SETUP^XUSRB()
 d VALIDAV^XUSRB(.user,accver)
 s personDuz=user(0)
 ;
 ;KBAZ/ZAG - add logic to check if verify code needs to be changed.
 ;0 = VC does not need to be changed
 ;1 = VC needs to be changed
 s V4WVCC=$g(user(2))
 s V4WCVMSG=$g(user(3)) ;sign in message
 ;
 s termReason=""
 i 'personDuz,$G(DUZ) s termReason=": "_$$GET1^DIQ(200,DUZ_",",9.4) ;Termination reason
 i 'personDuz QUIT user(3)_termReason
 ;
 s personName=$p(^VA(200,personDuz,0),"^")
 s displayPersonName=$p(personName,",",2)_" "_$p(personName,",")
 s results("DT")=DT
 s results("DUZ")=personDuz
 s results("username")=personName
 s results("displayName")=displayPersonName
 s results("greeting")=$g(user(7))
 k ^CacheTempEWD($j)
 m ^CacheTempEWD($j)=results
 k ^rob("login") m ^rob("login")=results
 QUIT ""
 ;
getWorkList() ;
 ;
 n arr
 ;
 s arr("FILE")=75.1
 s arr("FLAGS")="PB"
 s arr("FIELDS")=".01I;.01;4;14;16;2;3;20;6;26;19;21;7I;5I"
 s arr("PART")=""
 s arr("XREF")="#"
 QUIT $$ddrLister(.arr)
 ;
ddrLister()
 ;
 k
 n arr,temp,XWBAPVER
 ;
 m arr=^CacheTempEWD($j)
 s XWBAPVER=1 
 d LISTC^DDR(.temp,.arr)
 k ^CacheTempEWD($j)
 QUIT temp
 ;
ddrGetsEntry(file,iens,field,flags)
 ;
 k (file,iens,field,flags)
 n array
 n DIERR,DILOCKTM,DISYS,DT,DTIME,DUZ,IO,U
 ;
 s file=$g(file) 
 s iens=$g(iens)
 i $e(iens,$l(iens))'="," s iens=iens_","
 s field=$g(field)
 i field="" s field="*"
 s flags=$g(flags)
 i flags="" s flags="IEN"
 d GETS^DIQ(file,iens,field,flags,"array")
 k ^CacheTempEWD($j)
 m ^CacheTempEWD($j)=array(file)
 QUIT 1
 ;
orig	;
	s fn="" f  s fn=$o(results(fn)) q:fn=""  d
	. i fn'=fileNo s sfName=$p($g(^DD(fn,0)),"^",1) s:$L(sfName," SUB-FIELD")>1 sfName=$p(sfName," SUB-FIELD",1) S sfName=$$validName(sfName)
	. s sfIen="",sfCount=0 f  s sfIen=$o(results(fn,sfIen)) q:sfIen=""  d
	.. s fieldName="" f  s fieldName=$o(results(fn,sfIen,fieldName)) q:fieldName=""  d
	... i fn=fileNo m outputs(fileName,$$validName(fieldName))=results(fn,sfIen,fieldName) q
	... m outputs(fileName,sfName,sfCount,$$validName(fieldName))=results(fn,sfIen,fieldName)
	.. i fn'=fileNo s sfCount=sfCount+1
	m ^%zewdTemp($j,"outputs")=outputs
	s ^cpc("g")=2
	s ^cpc("g",fileNo)=2
	q ""
treeIt
	n count,fileno,parent,parentName,previous,reversetxt,subfiletxt,treeIndex,treeout,tree
	k treeout
	;i fileNo=55 M ^cpc("results")=results
	s fileno="" f  s fileno=$o(results(fileno)) q:fileno=""  d
	. i fileno=55.09 s ^cpc(55)=9 q  ;special performance fix for meds - ignore acivity log
	. i fileno=55.03 s ^cpc(55)=4 q  ;special performance fix for meds - prescription profile
	. i fileno=55.04 s ^cpc(55)=4 q  ;special performance fix for meds - ignore acivity log
	. i fileno=55.0105 s ^cpc(55)=4 q  ;special performance fix for meds - ignore BCMA
	. i fileno=55.1057 s ^cpc(55)=4 q  ;special performance fix for meds - ignore acivity log
	. i fileno=55.1058 s ^cpc(55)=4 q  ;special performance fix for meds - ignore acivity log
	. i fileno=55.1111 s ^cpc(55)=4 q  ;special performance fix for meds - ignore acivity log
	. i fileno=55.0611 s ^cpc(55)=4 q  ;special performance fix for meds - ignore acivity log
	. i fileno=100.09 q
	. i fileno=100.0085 q
	. i fileno=100.045  q  ;special performance fix for 
	. i fileno=100.0451  q  ;special performance fix for 
	. i fileno=100.008  q  ;special performance fix for 
	. i fileno=100.0081  q  ;special performance fix for 
	. i fileno=100.0082  q  ;special performance fix for 
	. s subfiletxt="" f  s subfiletxt=$o(results(fileno,subfiletxt)) q:subfiletxt=""  D
	.. s reversetxt=$$reverse(subfiletxt)
	.. m treeout(reversetxt,fileno)=results(fileno,subfiletxt)
	s parent="",previous=""
	s sfIen="" f  s sfIen=$o(treeout(sfIen)) q:sfIen=""  d
	. s parent=$p(sfIen,",",1,($l(sfIen,",")-2))_","
	. i $l(sfIen,",")'=$l(previous) s count=0 s previous=sfIen
	. s fn="" f  s fn=$o(treeout(sfIen,fn)) q:fn=""  d
	..  i fn'=fileNo s sfName=$p($g(^DD(fn,0)),"^",1) s:$L(sfName," SUB-FIELD")>1 sfName=$p(sfName," SUB-FIELD",1) S sfName=$$validName(sfName)
	..   s count=$o(tree(parent,sfName,""),-1) s:count'="" count=count+1 s:count="" count=0
	..  s fieldName="" f  s fieldName=$o(treeout(sfIen,fn,fieldName)) q:fieldName=""  d
	...   i fn=fileNo m outputs(fileName,$$validName(fieldName))=treeout(sfIen,fn,fieldName) q
	...   m tree(parent,sfName,count,$$validName(fieldName))=treeout(sfIen,fn,fieldName)
	...   s treeIndex(sfIen)=count
	s sfIen="" f  s sfIen=$o(tree(sfIen),-1) q:sfIen=ienX  q:sfIen=""  d
	. s parent=$p(sfIen,",",1,($l(sfIen,",")-2))_","
	. s parentName=$o(tree(parent,""))
	. ;q:parent=","
	. m tree(parent,parentName,treeIndex(sfIen))=tree(sfIen)
	. k tree(sfIen)
	;i fileNo=55 m ^cpc("tree")=tree(ienX)
	m outputs(fileName)=tree(ienX)
	;k trIn
	;m trIn=treeout
	q
reverse(in)
	n i,out,c
	s c=","
	s out="" f i=($l(in,c)-1):-1:1 s out=out_$p(in,c,i)_c
	q out
field(file,fileien,out,flag)	;
	n fieldName
	k out
	s fieldName="" f  s fieldName=$o(results(file,fileien,fieldName)) q:fieldName=""  d
	. m out($$validName(fieldName))=results(file,fileien,fieldName)
	q
wrapGetDemographics(z)
	m inputs=^%zewdTemp($j,"inputs")
	s ok=$$getDemographics^JJOHSCRP(.inputs,.results)
	m ^%zewdTemp($j,"outputs")=results
	q ok
validName(in)
	n i,up,low,othIn,othOut,out
	s up="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	s low="abcdefghijklmnopqrstuvwxyz"
	s othIn="/-&()*.?"
	s othOut="________"
	s out=""
	f i=1:1:$l(in," ") s x=$p(in," ",i) s out=out_$TR($e(x,1),"*","_")_$tr($e(x,2,$l(x)),up_othIn,low_othOut)
	q out
wrapNewAllergy(z)
	m inputs=^%zewdTemp($j,"inputs")
	;m ^cpc("d")=inputs
	s ok=$$newAllergy^ZZCPCR00(.inputs,.outputs)
	m ^%zewdTemp($j,"outputs")=outputs
	q ok
newAllergy(inputs,outputs) ;function to create a new patient allergy entry
	n %,%I,%H,comdel,commref,comments,COUNT,DFN,DILOCKTM,DISYS,DT,DTIME,IO,U,X,now,DUZ,ERRORS,FDA,IEN,reactant,reactantPntr,observeOrHist,other,text
	;s ^cpc("a")=1
	S DUZ=$G(inputs("userId")) i 'DUZ Q "User not supplied"
	S DFN=$G(inputs("patientId")) i 'DFN Q "Patient not supplied"
	s reactant=$g(inputs("reactant")) i reactant="" q "reaction mandatory"
	s reactantPntr=$g(inputs("reactPntr")) i reactantPntr="" q "reaction pointer mandatory"
	s observeOrHist=$g(inputs("observedOrHistoric")) i observeOrHist="" q "observation time must be entered"
	;s:observeOrHist="" observeOrHist="h"
	i $d(inputs("reactions")) m other=inputs("reactions")
	;i other m other=inputs("reactions")
	s comments=$g(inputs("comments"))
	;i comments m other=inputs("comments")
	s comDel="\u000a"
	d NOW^%DTC s DT=X,now=%
	;s ^cpc("a")=2.0
	;s other=1,other(1)=133
	;s comments=1,comments(1,"date")=DT,comments(1,"text",1)="some text Comment",comments(1,"text",2)="split over two lines"
	S FDA(120.8,"+1,",.01)=DFN
	S FDA(120.8,"+1,",.02)=reactant
	S FDA(120.8,"+1,",1)=reactantPntr
	s FDA(120.8,"+1,",4)=DT
	s FDA(120.8,"+1,",5)=DUZ
	s FDA(120.8,"+1,",6)=observeOrHist
	;s ^cpc("a")=2.1
	I +$g(other) f count=1:1:$l(other,",") d
	. s FDA(120.81,"+"_(count+1)_",+1,",.01)=$p(other,",",count)
	. s FDA(120.81,"+"_(count+1)_",+1,",2)=DUZ
	. s FDA(120.81,"+"_(count+1)_",+1,",3)=DT
	;s ^cpc("a")=2.2
	k text
	I comments'="" d
	. f count=1:1:$l(comments,comDel) s text(1,count)=$p(comments,comDel,count)
	. s commRef="text(1)"
	. s FDA(120.826,"+"_(+20)_",+1,",.01)=DT
	. s FDA(120.826,"+"_(+20)_",+1,",1)=DUZ
	. s FDA(120.826,"+"_(+20)_",+1,",2)=commRef
	;s ^cpc("a")=3
	D UPDATE^DIE("S","FDA","IEN","ERRORS")
	;s ^cpc("a")=4
	i $d(ERRORS) m outputs("ERRORS")=ERRORS Q ERRORS("DIERR",1,"TEXT",1)
	s ^cpc("a")=5
	m outputs=IEN
	q ""
	;
test() ;
	QUIT $zu(5)
	;



